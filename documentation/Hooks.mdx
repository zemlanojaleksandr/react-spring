---
name: React hooks ⚠️
route: /hooks
order: 1
---

import { PropsTable } from 'docz'
import { Spring, animated, config } from '../src/targets/web'
import {
  AnimatedMeter,
  RewindSpringProvider,
  RewindSpring,
} from './resources/RewindSpring.js'
import CodeMirror from './resources/Codemirror'
import DemoGrid from '../examples/components/DemoGrid'
import Demo from '../examples/components/Demo'
import examples from '../examples/components/examples-hooks'

# Hooks

<p>
  <span className="highlight">Warning: experimental API!</span> Due to hooks being alpha in React the underlying React API as well as the userfacing react-spring API can be subject to changes. Hooks in react-spring are in a separate export in order to not interfere with the stable releases. As of version 7 this export is officially part of the npm package. Test it, use it, enjoy it, but we recommend that you consult this page if you encounter problems or file issues on <a href="https://github.com/drcmda/react-spring/issues">Github</a>.
</p>

## What is this?

The React team has recently [unveiled hooks](https://conf.reactjs.org/). This feature allows you to create functional components with linear intent that can store permanent data and cause effects. react-spring now offers all primitives as hooks. You'll need both react@next and react-dom@next to use it.

```jsx
import {
  useSpring,
  useTransition,
  useTrail,
  useKeyframes,
  animated,
} from 'react-spring/hooks'
```

## useSpring

 `useSpring(Values | () => Values): animatedProps | [animatedProps, set]`

<p>
 useSpring accepts props and returns animated-props, which you can then distribute among your views. It behaves like the <a href="/spring">spring</a> component you already know. For all full table of all accepted props concult the spring components documentation.
</p>

<p>
  <h3>Either: <span className="highlight">overwrite values</span> to change the animation</h3>
</p>

If you re-render the component with changed props, the animation will update.

```jsx
const props = useSpring({ opacity: 1, from: { opacity: 0 } })
```

<p>
  <h3>Or: <span className="highlight">pass a function</span> that returns values and an updater-function</h3>
</p>

You will get a `set(Values)` function back, use it to update the animation. This will not cause the component to render, which can generally more performant.

```jsx
const [props, set] = useSpring(() => ({ opacity: 1, from: { opacity: 0 } }))
```

<p>
  <h3>Finally: <span className="highlight">distribute animated props</span> among the view</h3>
</p>

The return value is an object containing animated props. 

```jsx
return <animated.div style={props}>i will fade in</animated.div>
```

<DemoGrid padding={0}>
  {examples.filter(data => data.tags.includes('useSpring')).map(data => (
    <Demo
      key={data.name}
      {...data}
      import={import('../examples/demos/' + data.name)}
    />
  ))}
</DemoGrid>

## useTrail

 `useTrail(Count, Values | () => Values): animatedProps | [animatedProps, set]`

<p>
 useTrail needs the amount of items you want to trail and the props you want to animate. It returns an array of animated-props, which you can then distribute among your views. It behaves like the <a href="/trail">trail</a> component you already know.
</p>

<p>
  <h3>Either: <span className="highlight">overwrite values</span> to change the animation</h3>
</p>

If you re-render the component with changed props, the animation will update.

```jsx
const props = useTrail(items.length, { items, opacity: 1, from: { opacity: 0 } })
```

<p>
  <h3>Or: <span className="highlight">pass a function</span> that returns values and an updater-function</h3>
</p>

You will get a `set(Values)` function back, use it to update the animation. This will not cause the component to render, which can generally more performant.

```jsx
const [props, set] = useTrail(items.length, () => ({ items, opacity: 1, from: { opacity: 0 } }))
```

<p>
  <h3>Finally: <span className="highlight">distribute animated props</span> among the view</h3>
</p>

The return value is an array or objects, each containing the item and its animated props. 

```jsx
return items.map((item, index) => (
  <animated.div key={item.key} style={props[index]}>{item}</animated.div>
)
```

<DemoGrid padding={0}>
  {examples.filter(data => data.tags.includes('useTrail')).map(data => (
    <Demo
      key={data.name}
      {...data}
      import={import('../examples/demos/' + data.name)}
    />
  ))}
</DemoGrid>

## useTransition

 `useTransition(Config): animatedProps`

The useTransition hook replaces `<Transition />`. You give it data and it returns animated-props, which you can then distribute among your views. You can update data either by overwriting it, or by calling `set` which updates the spring without causing a render pass (which is great for iteractive input, mouse events, etc).

```jsx
const [items] = useState(['A', 'B', 'C'])
const transitions = useTransition({
  items,
  from: { opacity: 0 },
  enter: { opacity: 1 },
  leave: { opacity: 0 },
})
return transitions.map(({ item, key, props }) => (
  <animated.div key={key} style={props}>
    {item}
  </animated.div>
))
```

<DemoGrid padding={0}>
  {examples.filter(data => data.tags.includes('useTransition')).map(data => (
    <Demo
      key={data.name}
      {...data}
      import={import('../examples/demos/' + data.name)}
    />
  ))}
</DemoGrid>

## useKeyframes

 `useKeyframes.[spring|trail](Config): useFunction(SlotName)`

The useKeyframes replaces the `Keyframes` factory. It has almost the same API. You give it named slots (or a function, or an array) and you will get a function back that can toggle between them. If you do not use slots (when you either declare a function or an array as the first argument) you don't need to pass anything in the toggle function.

You can use also trail keyframes by using `useKeyframes.trail`

```jsx
const useSlot = useKeyframes.spring({
  // Single props
  show: { opacity: 1 },
  // Chained animations (arrays)
  showAndHide: [{ opacity: 1 }, { opacity: 0 }],
  // Functions with side-effects with access to component props
  wiggle: async (next, cancel, ownProps) => {
    await next({ x: 100 })
    await delay(1000)
    await next({ x: 0 })
  },
})

function App() {
  const [state, set] = useState('show')
  const props = useSlot(state)
  return <animated.div style={props}>content</animated.div>
}
```

<DemoGrid padding={0}>
  {examples.filter(data => data.tags.includes('useKeyframes')).map(data => (
    <Demo
      key={data.name}
      {...data}
      import={import('../examples/demos/' + data.name)}
    />
  ))}
</DemoGrid>
