---
name: React hooks
route: /hooks
order: 1
---

import { PropsTable } from 'docz'
import { Spring, animated, config } from '../src/targets/web'
import {
  AnimatedMeter,
  RewindSpringProvider,
  RewindSpring,
} from './resources/RewindSpring.js'
import CodeMirror from './resources/Codemirror'
import DemoGrid from '../examples/components/DemoGrid'
import Demo from '../examples/components/Demo'
import examples from '../examples/components/examples-hooks'

# Hooks

The React team has recently [unveiled hooks](https://conf.reactjs.org/). This feature allows you to create fully capable functional components that can store permanent data and cause effects. All react-spring primitives are now available as hooks. Hooks are still in alpha, you'll need both react@next and react-dom@next to use it.

```jsx
import {
  useSpring,
  useTransition,
  useTrail,
  useKeyframes,
  animated,
} from 'react-spring/hooks'
```

## useSpring

 `useSpring(Values | () => Values): animatedProps | [animatedProps, set]`

<p>
 useSpring accepts props and returns animated-props, which you can then distribute among your views. It behaves like the <a href="/spring">spring</a> component you already know.
</p>

<p>
  <span className="highlight">There are two ways to update a spring hook.</span>
</p>

### Either: overwrite values to change the animation

```jsx
const props = useSpring({ opacity: 1, from: { opacity: 0 } })
```

### Or: pass values as a function that returns them

You will get a `set` function back, use it to change the animation without causing the component to render, which is generally more performant.

```jsx
const [props, set] = useSpring(() => ({ opacity: 1, from: { opacity: 0 } }))
```

### Finally: distribute animated props among the view

The return value is an object containing animated props. 

```jsx
return <animated.div style={props}>i will fade in</animated.div>
```

<DemoGrid padding={0}>
  {examples.filter(data => data.tags.includes('useSpring')).map(data => (
    <Demo
      key={data.name}
      {...data}
      import={import('../examples/demos/' + data.name)}
    />
  ))}
</DemoGrid>

## useTrail

 `useTrail(Values | () => Values): animatedProps | [animatedProps, set]`

<p>
 useTrail accepts an array of items, props and returns an array of animated-props, which you can then distribute among your views. It behaves like the <a href="/trail">trail</a> component you already know.
</p>

<p>
  <span className="highlight">There are two ways to update a trail hook.</span>
</p>

### Either: overwrite values to change the animation

```jsx
const trail = useTrail({ items, opacity: 1, from: { opacity: 0 } })
```

### Or: pass values as a function that returns them

You will get a `set` function back, use it to change the animation without causing the component to render, which is generally more performant.

```jsx
const [trail, set] = useTrail(() => ({ items, opacity: 1, from: { opacity: 0 } }))
```

### Finally: distribute animated props among the view

The return value is an array or objects, each containing the item and its animated props. 

```jsx
return trail.map(({ item, props }) => (
  <animated.div key={item.key} style={props}>{item}</animated.div>
)
```

<DemoGrid padding={0}>
  {examples.filter(data => data.tags.includes('useTrail')).map(data => (
    <Demo
      key={data.name}
      {...data}
      import={import('../examples/demos/' + data.name)}
    />
  ))}
</DemoGrid>

## useTransition

The useTransition hook replaces `<Transition />`. You give it data and it returns animated-props, which you can then distribute among your views. You can update data either by overwriting it, or by calling `set` which updates the spring without causing a render pass (which is great for iteractive input, mouse events, etc).

```jsx
const [items] = useState(['A', 'B', 'C'])
const transitions = useTransition({
  items,
  from: { opacity: 0 },
  enter: { opacity: 1 },
  leave: { opacity: 0 },
})
return transitions.map(({ item, key, props }) => (
  <animated.div key={key} style={props}>
    {item}
  </animated.div>
))
```

<DemoGrid padding={0}>
  {examples.filter(data => data.tags.includes('useTransition')).map(data => (
    <Demo
      key={data.name}
      {...data}
      import={import('../examples/demos/' + data.name)}
    />
  ))}
</DemoGrid>

## useKeyframes

The useKeyframes replaces the `Keyframes` factory. It has almost the same API. You give it named slots (or a function, or an array). You toggle these slots by passing the name of the slot you want to run as the second argument. If you do not use slots (when you either declare a function or an array as the first argument) you don't need the second argument.

You can use also trail keyframes by using `useKeyframes.trail`

```jsx
const useSlot = useKeyframes.spring({
  // Single props
  show: { opacity: 1 },
  // Chained animations (arrays)
  showAndHide: [{ opacity: 1 }, { opacity: 0 }],
  // Functions with side-effects with access to component props
  wiggle: async (next, cancel, ownProps) => {
    await next({ x: 100 })
    await delay(1000)
    await next({ x: 0 })
  },
})

function App() {
  const [state, set] = useState('show')
  const props = useSlot(state)
  return <animated.div style={props}>content</animated.div>
}
```

<DemoGrid padding={0}>
  {examples.filter(data => data.tags.includes('useKeyframes')).map(data => (
    <Demo
      key={data.name}
      {...data}
      import={import('../examples/demos/' + data.name)}
    />
  ))}
</DemoGrid>
