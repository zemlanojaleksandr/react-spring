---
name: useTrail
route: /useTrail
order: 60
---

import DemoGrid from '../examples/components/DemoGrid'
import Demo from '../examples/components/Demo'
import examples from '../examples/components/examples-hooks'

# useTrail

```js
import { useTrail, animated } from 'react-spring'
```

Creates multiple springs with a single config, each spring will follow the previous one. Use it for staggered animations.

### Either: overwrite values to change the animation

If you re-render the component with changed props, the animation will update.

```jsx
const trail = useTrail(number, { opacity: 1 })
```

### Or: pass a function that returns values, and update using "set"

You will get a `set` function back. It will not cause the component to render like an overwrite would (still the animation executes of course). Handling updates like this is useful for fast-occurring updates, but you should generally prefer it.

```jsx
const [trail, set] = useTrail(number, () => ({ opacity: 1 }))
// ...
set({ opacity: 0 })
```

### Finally: distribute animated props among the view

The return value is an array containing animated props.

```jsx
return trail.map(props => <animated.div style={props} />)
```

## Properties

All properties of the [shared-api](/api) apply.

## Demos

<DemoGrid padding={0}>
  {examples.filter(data => data.tags.includes('useTrail')).map(data => (
    <Demo
      key={data.name}
      {...data}
      import={import('../examples/demos/' + data.name)}
    />
  ))}
</DemoGrid>